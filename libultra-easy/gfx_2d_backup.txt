#include <ultra64.h>
#include <stdlib.h>
#include <math.h>
#include <PR/gs2dex.h>
#include <PR/gu.h>

#include "config/global.h"
#include "config/video.h"
#include "config/usb.h"

#include "libultra-easy/types.h"
#include "libultra-easy/fs.h"
#include "libultra-easy/rcp.h"

/* =========== STATIC HELPERS =========== */

static Gfx dl_sprite_init[] =
{
	gsDPPipeSync(),
	gsDPSetTexturePersp(G_TP_NONE),
	gsDPSetTextureLOD(G_TL_TILE),
	gsDPSetTextureLUT(G_TT_NONE),
	gsDPSetTextureConvert(G_TC_FILT),
	gsDPSetAlphaCompare(G_AC_THRESHOLD),
	gsDPSetBlendColor(0, 0, 0, 0x01),
	gsDPSetCombineMode(G_CC_DECALRGBA, G_CC_DECALRGBA),
	gsDPSetCycleType(G_CYC_1CYCLE),
	gsSPEndDisplayList(),
};

static int find_nearest_multiple(int input)
{
	int multiple_array[] = { 2, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 48, 64, 72, 76, 100, 108, 128, 144, 152, 164, 200, 216, 228, 256, 304, 328, 432, 456, 512, 684, 820, 912 };
	int multiple_i;

	while (multiple_array[multiple_i] < input && multiple_i < 32)
		multiple_i++;

	return multiple_array[multiple_i];
}

static void copy_img(void *img, int img_w, void *dest, int dest_w, int w, int h)
{
	int dest_x, dest_y;
    bzero(dest, sizeof(dest));

	for (dest_y = 0; dest_y < h; dest_y++)
	{
		// memcpy(dest + (dest_y * dest_w), img + (dest_y * img_w), w);
	    int *ptr = dest + (dest_w * dest_y);
		for (dest_x = 0; dest_x < w; dest_x++)
		{
		    ptr = img + (dest_y * img_w) + dest_x;
		    ptr++;
		}
	}
}

/* ============= FUNCTIONS ============== */

void sprite_init()
{
	gSPLoadUcodeL(glistp++, gspS2DEX2_fifo);
	gSPDisplayList(glistp++, dl_sprite_init);
}

void sprite_finish()
{
	gSPLoadUcodeL(glistp++, gspF3DEX2_fifo);

	// Execute RSP and RDP initialization
	rcp_init_rdp();
	rcp_init_rsp();
}

/* void sprite_draw_bg(uObjBg *bg, int x, int y, float scale_x, float scale_y, u8 r, u8 g, u8 b, u8 a)
{
	gSPBgRect1Cyc(glistp++, &bg);
} */

void setup_mtx(uObjMtx *buf, int x, int y, int scale)
{
	buf->m.A = 0x10000;
	buf->m.D = 0x10000;

	buf->m.X = x << 2;
	buf->m.Y = y << 2;

	buf->m.BaseScaleX = scale << 10;
	buf->m.BaseScaleY = scale << 10;
}

void sprite_create_tlut(sprite_t *spr, void *img, u16 *tlut, int w, int h, int frames, u8 img_siz)
{
	// Set texture entry properties
	spr->data.tex = img;

	// Set TLUT properties
	spr->data.tlut = tlut;
	spr->data.tlut_fmt = G_TT_RGBA16;

	// Assign properties to pointers
	spr->data.w = w;
	spr->data.h = h;
	spr->data.frames = frames;
	spr->data.img_fmt = G_IM_FMT_CI;
	spr->data.img_siz = img_siz;

	// Set properties
	spr->r = 255;
	spr->g = 255;
	spr->b = 255;
	spr->a = 255;
	spr->scale_x = 1;
	spr->scale_y = 1;
}

void sprite_create(sprite_t *spr, void *img, int w, int h, int frames, u8 fmt, u8 siz)
{
	// Set texture entry properties
	spr->data.tex = img;

	// Determine that this sprite does not use a TLUT palette
	spr->data.tlut = NULL;

	// Assign properties to pointers
	spr->data.w = w;
	spr->data.h = h;
	spr->data.frames = frames;
	spr->data.img_fmt = fmt;
	spr->data.img_siz = siz;

	// Set properties
	spr->r = 255;
	spr->g = 255;
	spr->b = 255;
	spr->a = 255;
	spr->scale_x = 1;
	spr->scale_y = 1;
}

void sprite_destroy(sprite_t *spr)
{
	// free(spr);
}

static void update_obj(uObjSprite *obj, sprite_t *spr)
{
	obj->s.objX = 0 << 2;
	obj->s.objY = 0 << 2;
	obj->s.scaleW = 1 << 10;
	obj->s.scaleH = 1 << 10;
	obj->s.imageW = spr->data.w << 5;
	obj->s.imageH = spr->data.h << 5;
	obj->s.paddingX = 0;
	obj->s.paddingY = 0;
	obj->s.imageAdrs = GS_PIX2TMEM(spr->data.h*spr->data.w+0, spr->data.img_siz);
	obj->s.imageStride = 0;
	obj->s.imageFmt = spr->data.img_fmt;
	obj->s.imageSiz = spr->data.img_siz;

	osWritebackDCache(&obj, sizeof(uObjSprite));
}

static void update_obj_slice(uObjSprite *obj, sprite_t *spr, int x, int y, int w, int h)
{
	obj->s.objX = x << 2;
	obj->s.objY = y << 2;
	obj->s.scaleW = 1 << 10;
	obj->s.scaleH = 1 << 10;
	obj->s.imageW = w << 5;
	obj->s.imageH = h << 5;
	obj->s.paddingX = 0;
	obj->s.paddingY = 0;
	obj->s.imageAdrs = GS_PIX2TMEM(y*spr->data.w+x, spr->data.img_siz);
	obj->s.imageStride = GS_PIX2TMEM(spr->data.w, spr->data.img_siz);
	obj->s.imageFmt = spr->data.img_fmt;
	obj->s.imageSiz = spr->data.img_siz;

	osWritebackDCache(&obj, sizeof(uObjSprite));
}

static void update_mtx(uObjMtx *mtx, sprite_t *spr)
{
	u16 angle = 0;
	if (angle != 0)
	{
		s32 c = (s32)coss(angle)*2;
		s32 s = (s32)sins(angle)*2;
		if (c == 0xFFFE) c = 0x10000;
		if (s == 0xFFFE) s = 0x10000;
		if (c == -0xFFFE) c = -0x10000;
		if (s == -0xFFFE) s = -0x10000;

		mtx->m.A = c*spr->scale_x;
		mtx->m.D = c*spr->scale_y;
		mtx->m.B = -s*spr->scale_x;
		mtx->m.C = s*spr->scale_y;
	}
	else
	{
		mtx->m.A = round(spr->scale_x * 65536.0);
		mtx->m.D = round(spr->scale_y * 65536.0);
		mtx->m.B = mtx->m.C = 0;
	}

	mtx->m.X = spr->x*4;
	mtx->m.Y = spr->y*4;
	osWritebackDCache(&mtx, sizeof(uObjMtx));
}

void sprite_draw(sprite_t *spr)
{
	uObjSprite obj;
	uObjMtx mtx;

	bool is_4b = spr->data.img_siz == G_IM_SIZ_4b;
	int texels_per_pixel = spr->data.img_siz == G_IM_SIZ_32b ? 1024
						 : spr->data.img_siz == G_IM_SIZ_16b ? 2048
						 : spr->data.img_siz == G_IM_SIZ_8b ? spr->data.img_fmt == G_IM_FMT_CI ? 2048 : 4096
						 : spr->data.img_fmt == G_IM_FMT_CI ? 4096 : 8192;

    s32 sx = (int) ((1<<10) / spr->scale_x + 0.5F);
    s32 sy = (int) ((1<<10) / spr->scale_y + 0.5F);

	// ******************************************
	gDPSetCombineMode(glistp++, G_CC_MODULATERGBA_PRIM, G_CC_MODULATERGBA_PRIM);
	gDPSetRenderMode(glistp++, G_RM_XLU_SURF, G_RM_XLU_SURF);
	gSPObjRenderMode(glistp++, G_OBJRM_XLU | G_OBJRM_BILERP);
	gDPSetPrimColor(glistp++, 0, 0, spr->r, spr->g, spr->b, spr->a);

	if (spr->data.tlut != NULL)
	{
		gDPSetTextureLUT(glistp++, G_TT_RGBA16);
		gDPLoadTLUT_pal256(glistp++, spr->data.tlut);
	}

	update_mtx(&mtx, spr);
	gSPObjMatrix(glistp++, &mtx);

	if (spr->data.w * spr->data.h > texels_per_pixel)
	{
		int i;
		int slice_height = 128;
		while (spr->data.w * slice_height > texels_per_pixel)
			slice_height /= 2;
		if (slice_height < 2) slice_height = 2;

		for (i = 0; i < spr->data.h; i += slice_height)
		{
			if (slice_height > spr->data.h - i)
				slice_height = spr->data.h - i;

			obj.s.imageAdrs = GS_PIX2TMEM(i*spr->data.w+0, spr->data.img_fmt);
			obj.s.imageStride = GS_PIX2TMEM(spr->data.w, spr->data.img_fmt);

			// Load texture as tile
			if (is_4b)
			{
				gDPLoadTextureTile_4b(
					glistp++,
					spr->data.frames > 1 ? (((u32 **)spr->data.tex)[spr->frame])
										 : ((u32 *)spr->data.tex),	// timg - Our sprite array
					//0,												// tmem - Address to store in TMEM
					//G_TX_RENDERTILE,								// rt - Tile descriptor

					// fmt - Our image format
					spr->data.img_fmt == G_IM_FMT_RGBA ? G_IM_FMT_RGBA :
					spr->data.img_fmt == G_IM_FMT_YUV ? G_IM_FMT_YUV :
					spr->data.img_fmt == G_IM_FMT_CI ? G_IM_FMT_CI :
					spr->data.img_fmt == G_IM_FMT_IA ? G_IM_FMT_IA :
					spr->data.img_fmt == G_IM_FMT_I ? G_IM_FMT_I :
					0,

					spr->data.w, spr->data.h,						// width, height of the full image

					// Top left corner of the rectangle
					0,
					i,

					// Bottom right corner
					spr->data.w - 1,
					i + slice_height - 1,

					0,
					G_TX_WRAP, G_TX_WRAP,
					0, 0,
					G_TX_NOLOD, G_TX_NOLOD
				);
			}

			else
			{
				gDPLoadTextureTile(
					glistp++,
					spr->data.frames > 1 ? (((u32 **)spr->data.tex)[spr->frame])
										 : ((u32 *)spr->data.tex),	// timg - Our sprite array
					//0,												// tmem - Address to store in TMEM
					//G_TX_RENDERTILE,								// rt - Tile descriptor

					// fmt - Our image format
					spr->data.img_fmt == G_IM_FMT_RGBA ? G_IM_FMT_RGBA :
					spr->data.img_fmt == G_IM_FMT_YUV ? G_IM_FMT_YUV :
					spr->data.img_fmt == G_IM_FMT_CI ? G_IM_FMT_CI :
					spr->data.img_fmt == G_IM_FMT_IA ? G_IM_FMT_IA :
					spr->data.img_fmt == G_IM_FMT_I ? G_IM_FMT_I :
					0,

					// size - Pixel size
					spr->data.img_siz == G_IM_SIZ_32b ? G_IM_SIZ_32b :
					spr->data.img_siz == G_IM_SIZ_16b ? G_IM_SIZ_16b :
					G_IM_SIZ_8b,

					spr->data.w, spr->data.h,						// width, height of the full image

					// Top left corner of the rectangle
					0,
					i,

					// Bottom right corner
					spr->data.w - 1,
					i + slice_height - 1,

					0,
					G_TX_WRAP, G_TX_WRAP,
					0, 0,
					G_TX_NOLOD, G_TX_NOLOD
				);
			}

			// Draw a rectangle
			update_obj_slice(&obj, spr, 0, i, spr->data.w, slice_height);
			gSPObjSprite(glistp++, &obj);
			/* gSPTextureRectangle(glistp++, 
				(spr->x)<<2,
				(spr->y + round(i * spr->scale_y))<<2,
				(spr->x + round(spr->data.w * spr->scale_x))<<2,
				(spr->y + round((i+slice_height) * spr->scale_y))<<2,
				G_TX_RENDERTILE,          // Tile descriptor
				0 << 5, i << 5,           // Starting S T Coordinate
				sx, sy                    // S T Increment
			); */
		}
	}
	else
	{
		/*// Load texture as block
		if (is_4b)
		{
			gDPLoadTextureBlock_4b(
				glistp++,
				spr->data.frames > 1 ? (((u32 **)spr->data.tex)[spr->frame])
									 : ((u32 *)spr->data.tex),	// timg - Our sprite array

				// fmt - Our image format
				spr->data.img_fmt == G_IM_FMT_RGBA ? G_IM_FMT_RGBA :
				spr->data.img_fmt == G_IM_FMT_YUV ? G_IM_FMT_YUV :
				spr->data.img_fmt == G_IM_FMT_CI ? G_IM_FMT_CI :
				spr->data.img_fmt == G_IM_FMT_IA ? G_IM_FMT_IA :
				spr->data.img_fmt == G_IM_FMT_I ? G_IM_FMT_I :
				0,

				spr->data.w, spr->data.h,						// width, height of the full image
				0,												// Palette to use (always 0)
				G_TX_WRAP, G_TX_WRAP,							// cms, cmt
				G_TX_NOMASK, G_TX_NOMASK,						// masks, maskt
				G_TX_NOLOD, G_TX_NOLOD							// shifts, shiftt
			);
		}

		else
		{
			gDPLoadTextureBlock(
				glistp++,
				spr->data.frames > 1 ? (((u32 **)spr->data.tex)[spr->frame])
									 : ((u32 *)spr->data.tex),	// timg - Our sprite array

				// fmt - Our image format
				spr->data.img_fmt == G_IM_FMT_RGBA ? G_IM_FMT_RGBA :
				spr->data.img_fmt == G_IM_FMT_YUV ? G_IM_FMT_YUV :
				spr->data.img_fmt == G_IM_FMT_CI ? G_IM_FMT_CI :
				spr->data.img_fmt == G_IM_FMT_IA ? G_IM_FMT_IA :
				spr->data.img_fmt == G_IM_FMT_I ? G_IM_FMT_I :
				0,

				// size - Pixel size
				spr->data.img_siz == G_IM_SIZ_32b ? G_IM_SIZ_32b :
				spr->data.img_siz == G_IM_SIZ_16b ? G_IM_SIZ_16b :
				G_IM_SIZ_8b,

				spr->data.w, spr->data.h, // width, height
				0,                        // Palette to use (always 0)
				G_TX_WRAP, G_TX_WRAP,     // cms, cmt
				(spr->data.w / 2), (spr->data.h / 2), // masks, maskt
				G_TX_NOLOD, G_TX_NOLOD    // shifts, shiftt
			);
		}*/
		uObjTxtrTile_t txtr =
		{
			G_OBJLT_TXTRTILE,
			spr->data.frames > 1 ? ((u32 **)spr->data.tex)[spr->frame]
								 : (u32 *)spr->data.tex,
			GS_PIX2TMEM(0, spr->data.img_siz),
			GS_TT_TWIDTH(spr->data.w, spr->data.img_siz),
			GS_TT_TWIDTH(spr->data.h, spr->data.img_siz),
			0,
			-1,
			0
		};
		gSPObjLoadTxtr(glistp++, &txtr);

		// Draw a rectangle
		update_obj(&obj, spr);
		gSPObjSprite(glistp++, &obj);
		/*gSPTextureRectangle(glistp++, 
			(spr->x)<<2,
			(spr->y)<<2,
			(spr->x + round(spr->data.w * spr->scale_x))<<2,
			(spr->y + round(spr->data.h * spr->scale_y))<<2,
			G_TX_RENDERTILE,		// Tile descriptor
			0 << 5, 0 << 5,			// Starting S T Coordinate
			sx, sy					// S T Increment
		);*/
	}

	gDPPipeSync(glistp++);
	if (spr->data.tlut != NULL)
	{
		gDPSetTextureLUT(glistp++, G_TT_NONE);
	}
}