struct sprite_data {
	void *img;
	void *pal;
	u8 fmt;
	u8 siz;

	u32 w;
	u32 h;
	u32 tile_count_x;
	u32 tile_count_y;
	u32 tile_w;
	u32 tile_h;

	int x;
	int y;

	int r;
	int g;
	int b;
	int a;
} typedef SpriteData;


--------------------------------------------------------------------


#include <ultra64.h>
#include <stdlib.h>
#include <PR/gs2dex.h>
#include <PR/gu.h>

#include "config/global.h"
#include "config/video.h"
#include "config/usb.h"

#include "lib/types.h"
#include "lib/fs.h"
#include "lib/gfx.h"

static Gfx dl_sprite_init[] =
{
	gsDPPipeSync(),
	gsDPSetTexturePersp(G_TP_NONE),
	gsDPSetTextureLOD(G_TL_TILE),
	gsDPSetTextureLUT(G_TT_NONE),
	gsDPSetTextureConvert(G_TC_FILT),
	gsDPSetAlphaCompare(G_AC_THRESHOLD),
	gsDPSetBlendColor(0, 0, 0, 0x01),
	gsDPSetCombineMode(G_CC_DECALRGBA, G_CC_DECALRGBA),
	gsSPEndDisplayList(),
};

/* ========== STATIC FUNCTIONS ========== */

static int find_nearest_multiple(int input)
{
	int multiple_array[] = { 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 48, 64, 72, 76, 100, 108, 128, 144, 152, 164, 200, 216, 228, 256, 304, 328, 432, 456, 512, 684, 820, 912 };
	int multiple_i;

	while (multiple_array[multiple_i] < input && multiple_i < 31)
		multiple_i++;

	return multiple_array[multiple_i];
}

/* ========== GLOBAL FUNCTIONS ========== */

void sprite_init()
{
	gSPLoadUcodeL(glistp++, gspS2DEX2_fifo);
	gSPDisplayList(glistp++, dl_sprite_init);
}

void sprite_finish()
{
	gSPLoadUcodeL(glistp++, gspF3DEX2_fifo);

	// Execute RSP and RDP initialization
	gfx_init_rdp();
	gfx_init_rsp();
}

SpriteData spr_blank = 
{
	.img = NULL,
	.pal = NULL,
	.fmt = G_IM_FMT_RGBA,
	.siz = G_IM_SIZ_16b,
	.w = 0,
	.h = 0,
	.tile_w = 32,
	.tile_h = 32,
	.tile_count_x = 1,
	.tile_count_y = 1,

	.x = 0,
	.y = 0,
	.r = 255,
	.g = 255,
	.b = 255,
	.a = 255,
};

SpriteData *sprite_create(void *img, void *pal, int w, int h, int w_tile, int h_tile, u8 fmt, u8 siz)
{
	// Declare sprite struct
	SpriteData *spr = &spr_blank;

	// Link internal values to declared
	spr->img = img;
	spr->pal = pal;
	spr->fmt = fmt;
	spr->siz = siz;

	// Set full image and tile sizes
	spr->w = w;
	spr->h = h;
	spr->tile_w = find_nearest_multiple(w_tile);
	spr->tile_h = find_nearest_multiple(h_tile);

	// Set other parameters
	spr->tile_count_x = spr->w / spr->tile_w;
	spr->tile_count_y = spr->h / spr->tile_h;
	spr->x = 0;
	spr->y = 0;

	spr->r = 255;
	spr->g = 255;
	spr->b = 255;
	spr->a = 255;

	return spr;
}

void sprite_destroy(SpriteData *spr)
{
	// free(spr);
}

void sprite_draw(SpriteData *spr)
{
	int tile_x, tile_y;

	// Set up DL
    gDPSetCycleType(glistp++, G_CYC_1CYCLE);
    gDPSetRenderMode(glistp++, G_RM_AA_TEX_EDGE, G_RM_AA_TEX_EDGE);

	// ******************************************

	// Init palette
	// gDPSetPrimColor(glistp++, 0, 0, spr->r, spr->g, spr->b, spr->a);

	// ******************************************

	for (tile_y = 0; tile_y < spr->tile_count_y; tile_y++)
	{
		for (tile_x = 0; tile_x < spr->tile_count_x; tile_x++)
		{
			int final_width = spr->tile_w;
			int final_height = spr->tile_h;
			int final_x = tile_x * spr->tile_w;
			int final_y = tile_y * spr->tile_h;

			if (final_x + final_width > spr->w)
				final_width = spr->w - final_x;
			if (final_y + final_height > spr->h)
				final_height = spr->h - final_y;

			gDPLoadMultiTile
			(
				glistp++,
				spr->img, // timg - Our sprite array
				0, // tmem - Address to store in TMEM
				G_TX_RENDERTILE,

				spr->fmt == G_IM_FMT_I ? G_IM_FMT_I : 
				spr->fmt == G_IM_FMT_IA ? G_IM_FMT_IA :
				spr->fmt == G_IM_FMT_YUV ? G_IM_FMT_YUV : 
				spr->fmt == G_IM_FMT_CI ? G_IM_FMT_CI : G_IM_FMT_RGBA,   
				// fmt - Our image format

				spr->siz == G_IM_SIZ_4b ? G_IM_SIZ_4b : 
				spr->siz == G_IM_SIZ_8b ? G_IM_SIZ_8b : 
				spr->siz == G_IM_SIZ_32b ? G_IM_SIZ_32b : G_IM_SIZ_16b,
				// size - Pixel size

				spr->w,
				spr->h,
				final_x,
				final_y,
				final_x + final_width - 1,
				final_y + final_height - 1,

				0,
				G_TX_WRAP, G_TX_WRAP,     // cms, cmt
				G_TX_NOMASK, G_TX_NOMASK, // masks, maskt
				G_TX_NOLOD, G_TX_NOLOD    // shifts, shiftt
			);

			gSPTextureRectangle
			(
				glistp++, 
				(spr->x + final_x) << 2,
				(spr->y + final_y) <<2,
				(spr->x + final_x + final_width) << 2,
				(spr->y + final_y + final_height) <<2,
				G_TX_RENDERTILE,          // Tile descriptor
				0 << 5, 0 << 5,           // Starting S T Coordinate
				1 << 10, 1 << 10          // S T Increment
			);

			gDPPipeSync(glistp++);
		}
	}

	gDPSetTextureLUT(glistp++, G_TT_NONE);
}




#include <ultra64.h>
#include <stdlib.h>
#include <PR/gs2dex.h>
#include <PR/gu.h>

#include "config/global.h"
#include "config/video.h"
#include "config/usb.h"

#include "libultra-easy/types.h"
#include "libultra-easy/fs.h"
#include "libultra-easy/gfx.h"

/* =========== STATIC HELPERS =========== */

static Gfx dl_sprite_init[] =
{
	gsDPPipeSync(),
	gsDPSetTexturePersp(G_TP_NONE),
	gsDPSetTextureLOD(G_TL_TILE),
	gsDPSetTextureLUT(G_TT_NONE),
	gsDPSetTextureConvert(G_TC_FILT),
	gsDPSetAlphaCompare(G_AC_THRESHOLD),
	gsDPSetBlendColor(0, 0, 0, 0x01),
	gsDPSetCombineMode(G_CC_DECALRGBA, G_CC_DECALRGBA),
	gsSPEndDisplayList(),
};

static int find_nearest_multiple(int input)
{
	int multiple_array[] = { 2, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 48, 64, 72, 76, 100, 108, 128, 144, 152, 164, 200, 216, 228, 256, 304, 328, 432, 456, 512, 684, 820, 912 };
	int multiple_i;

	while (multiple_array[multiple_i] < input && multiple_i < 32)
		multiple_i++;

	return multiple_array[multiple_i];
}

static void copy_img(void *img, int img_w, void *dest, int dest_w, int w, int h)
{
	int dest_x, dest_y;
    bzero(dest, sizeof(dest));

	for (dest_y = 0; dest_y < h; dest_y++)
	{
		// memcpy(dest + (dest_y * dest_w), img + (dest_y * img_w), w);
	    int *ptr = dest + (dest_w * dest_y);
		for (dest_x = 0; dest_x < w; dest_x++)
		{
		    ptr = img + (dest_y * img_w) + dest_x;
		    ptr++;
		}
	}
}

/* ============= TEMPLATES ============== */

uObjSprite obj =
{{
	.objX		 = 0 << 2,
	.objY		 = 0 << 2,
	.scaleW		 = 1 << 10,
	.scaleH		 = 1 << 10,
	.imageW		 = 16 << 5,
	.imageH		 = 16 << 5,
	.imageStride = GS_PIX2TMEM(16, G_IM_SIZ_16b),
	.imageAdrs   = GS_PIX2TMEM(0, G_IM_SIZ_16b),
	.imageFmt	 = G_IM_FMT_RGBA,
	.imageSiz	 = G_IM_SIZ_16b,
}};

static uObjTxtrTile_t tex;
static uObjTxtrTLUT_t tlut;

/* ============= FUNCTIONS ============== */

void sprite_init()
{
	gSPLoadUcodeL(glistp++, gspS2DEX2_fifo);
	gSPDisplayList(glistp++, dl_sprite_init);
}

void sprite_finish()
{
	gSPLoadUcodeL(glistp++, gspF3DEX2_fifo);

	// Execute RSP and RDP initialization
	gfx_init_rdp();
	gfx_init_rsp();
}

/* void sprite_draw_bg(uObjBg *bg, int x, int y, float scale_x, float scale_y, u8 r, u8 g, u8 b, u8 a)
{
	gSPBgRect1Cyc(glistp++, &bg);
} */

void setup_mtx(uObjMtx *buf, int x, int y, int scale)
{
	buf->m.A = 0x10000;
	buf->m.D = 0x10000;

	buf->m.X = x << 2;
	buf->m.Y = y << 2;

	buf->m.BaseScaleX = scale << 10;
	buf->m.BaseScaleY = scale << 10;
}

void sprite_create_tlut(sprite_t *spr, void *img, u16 *tlut, int w, int h, int frames, u8 img_siz)
{
	// Set texture entry properties
	spr->data.tex = img;

	// Set TLUT properties
	spr->data.tlut = tlut;
	spr->data.tlut_fmt = G_TT_RGBA16;

	// Assign properties to pointers
	spr->data.w = w;
	spr->data.h = h;
	spr->data.frames = frames;
	spr->data.img_fmt = G_IM_FMT_CI;
	spr->data.img_siz = img_siz;

	// Set properties
	spr->r = 255;
	spr->g = 255;
	spr->b = 255;
	spr->a = 255;
	spr->scale_x = 1;
	spr->scale_y = 1;
}

void sprite_create(sprite_t *spr, void *img, int w, int h, int frames, u8 fmt, u8 siz)
{
	// Set texture entry properties
	spr->data.tex = img;

	// Determine that this sprite does not use a TLUT palette
	spr->data.tlut = NULL;

	// Assign properties to pointers
	spr->data.w = w;
	spr->data.h = h;
	spr->data.frames = frames;
	spr->data.img_fmt = fmt;
	spr->data.img_siz = siz;

	// Set properties
	spr->r = 255;
	spr->g = 255;
	spr->b = 255;
	spr->a = 255;
	spr->scale_x = 1;
	spr->scale_y = 1;
}

void sprite_destroy(sprite_t *spr)
{
	// free(spr);
}

void sprite_draw(sprite_t *spr)
{
	int t;

	setup_mtx(&(spr->data.mtx), spr->x, spr->y, spr->scale_x);

	// Set up DL
	// gDPSetCycleType(glistp++, G_CYC_1CYCLE);
	// gDPSetCombineMode(glistp++, G_CC_MODULATERGBA_PRIM, G_CC_MODULATERGBA_PRIM);
	// gDPSetRenderMode(glistp++, G_RM_XLU_SURF, G_RM_XLU_SURF);
	if (spr->data.tlut != NULL)
	{
		int tlut_size = (sizeof(spr->data.tlut) / sizeof(u16)) + 1;

		tlut.type = G_OBJLT_TLUT;
		tlut.image = (u64 *)spr->data.tlut;
		tlut.phead = GS_PAL_HEAD(0);
		tlut.pnum = GS_PAL_NUM(tlut_size);
		tlut.zero = 0;
		tlut.sid = 0;
		tlut.flag = (u32)spr->data.tlut;
		tlut.mask = -1;

		gDPSetTextureLUT(glistp++, G_TT_RGBA16);
	}
	// gSPObjRenderMode(glistp++, G_OBJRM_XLU | G_OBJRM_BILERP);

	obj.s.objY = 0 << 2;
	obj.s.imageW = (spr->data.tile_w) << 5;
	obj.s.imageH = (spr->data.tile_h) << 5;
	obj.s.imageStride = GS_PIX2TMEM(spr->data.tile_w, spr->data.img_siz);
	obj.s.imageAdrs = GS_PIX2TMEM(0, spr->data.img_siz);
	obj.s.imageFmt = spr->data.img_fmt;
	obj.s.imageSiz = spr->data.img_siz;
	obj.s.imagePal = 0;
	obj.s.imageFlags = 0;

	tex.type = G_OBJLT_TXTRTILE;
	tex.tmem = GS_PIX2TMEM(0, spr->data.img_siz);
	tex.twidth = GS_TT_TWIDTH(spr->data.tile_w, spr->data.img_siz);
	tex.theight = GS_TT_THEIGHT(spr->data.tile_h, spr->data.img_siz);
	tex.flag = 0;
	tex.mask = -1;

	// ******************************************

	// Setup matrices
	for (t = 0; t < spr->data.tiles; t++)
	{
		// Set uObjSprite properties
		obj.s.objX = (spr->data.tile_w * t) << 2;

		gDPSetPrimColor(glistp++, 0, 0, spr->r, spr->g, spr->b, spr->a);

		// Load texture as tile
		tex.image = (u64 *)(((u32 **)spr->data.tex)[t]);
		gSPObjLoadTxtr(glistp++, &tex);

		// Load TLUT palette if it exists
		if (spr->data.tlut != NULL)
			gSPObjLoadTxtr(glistp++, &tlut);

		// Write matrix to DL
		// osWritebackDCache(&(spr->data.mtx), sizeof(uObjMtx));
		gSPObjMatrix(glistp++, &(spr->data.mtx));

		// osWritebackDCache(&obj, sizeof(uObjSprite));
		gSPObjSprite(glistp++, &obj);
	}
}





















#include <ultra64.h>
#include <stdlib.h>
#include <PR/gs2dex.h>
#include <PR/gu.h>

#include "config/global.h"
#include "config/video.h"
#include "config/usb.h"

#include "libultra-easy/types.h"
#include "libultra-easy/fs.h"
#include "libultra-easy/gfx.h"

/* =========== STATIC HELPERS =========== */

static Gfx dl_sprite_init[] =
{
	gsDPPipeSync(),
	gsDPSetTexturePersp(G_TP_NONE),
	gsDPSetTextureLOD(G_TL_TILE),
	gsDPSetTextureLUT(G_TT_NONE),
	gsDPSetTextureConvert(G_TC_FILT),
	gsDPSetAlphaCompare(G_AC_THRESHOLD),
	gsDPSetBlendColor(0, 0, 0, 0x01),
	gsDPSetCombineMode(G_CC_DECALRGBA, G_CC_DECALRGBA),
	gsSPEndDisplayList(),
};

static int find_nearest_multiple(int input)
{
	int multiple_array[] = { 2, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 48, 64, 72, 76, 100, 108, 128, 144, 152, 164, 200, 216, 228, 256, 304, 328, 432, 456, 512, 684, 820, 912 };
	int multiple_i;

	while (multiple_array[multiple_i] < input && multiple_i < 32)
		multiple_i++;

	return multiple_array[multiple_i];
}

static void copy_img(void *img, int img_w, void *dest, int dest_w, int w, int h)
{
	int dest_x, dest_y;
    bzero(dest, sizeof(dest));

	for (dest_y = 0; dest_y < h; dest_y++)
	{
		// memcpy(dest + (dest_y * dest_w), img + (dest_y * img_w), w);
	    int *ptr = dest + (dest_w * dest_y);
		for (dest_x = 0; dest_x < w; dest_x++)
		{
		    ptr = img + (dest_y * img_w) + dest_x;
		    ptr++;
		}
	}
}

/* ============= TEMPLATES ============== */

uObjSprite obj =
{{
	.objX		 = 0 << 2,
	.objY		 = 0 << 2,
	.scaleW		 = 1 << 10,
	.scaleH		 = 1 << 10,
	.imageW		 = 16 << 5,
	.imageH		 = 16 << 5,
	.imageStride = GS_PIX2TMEM(16, G_IM_SIZ_16b),
	.imageAdrs   = GS_PIX2TMEM(0, G_IM_SIZ_16b),
	.imageFmt	 = G_IM_FMT_RGBA,
	.imageSiz	 = G_IM_SIZ_16b,
}};

static uObjTxtrTile_t tex;
static uObjTxtrTLUT_t tlut;

/* ============= FUNCTIONS ============== */

void sprite_init()
{
	gSPLoadUcodeL(glistp++, gspS2DEX2_fifo);
	gSPDisplayList(glistp++, dl_sprite_init);
}

void sprite_finish()
{
	gSPLoadUcodeL(glistp++, gspF3DEX2_fifo);

	// Execute RSP and RDP initialization
	gfx_init_rdp();
	gfx_init_rsp();
}

/* void sprite_draw_bg(uObjBg *bg, int x, int y, float scale_x, float scale_y, u8 r, u8 g, u8 b, u8 a)
{
	gSPBgRect1Cyc(glistp++, &bg);
} */

void setup_mtx(uObjMtx *buf, int x, int y, int scale)
{
	buf->m.A = 0x10000;
	buf->m.D = 0x10000;

	buf->m.X = x << 2;
	buf->m.Y = y << 2;

	buf->m.BaseScaleX = scale << 10;
	buf->m.BaseScaleY = scale << 10;
}

void sprite_create_with_tlut(sprite_t *spr, void *img, u16 *tlut, int w, int h, int tiles, u8 img_siz)
{
	// Set texture entry properties
	spr->data.tex = img;

	// Set TLUT properties
	spr->data.tlut = tlut;
	spr->data.tlut_fmt = G_TT_RGBA16;

	// Assign properties to pointers
	setup_mtx(&(spr->data.mtx), 0, 0, 1);
	spr->data.tiles = tiles;
	spr->data.w = w;
	spr->data.h = h;
	spr->data.img_fmt = G_IM_FMT_CI;
	spr->data.img_siz = img_siz;

	// Set properties
	spr->r = 255;
	spr->g = 255;
	spr->b = 255;
	spr->a = 255;
	spr->scale_x = 1;
	spr->scale_y = 1;
}

void sprite_create(sprite_t *spr, void *img, int w, int h, int tiles, u8 fmt, u8 siz)
{
	// Set texture entry properties
	spr->data.tex = img;

	// Determine that this sprite does not use a TLUT palette
	spr->data.tlut_fmt = -1;

	// Assign properties to pointers
	setup_mtx(&(spr->data.mtx), 0, 0, 1);
	spr->data.tiles = tiles;
	spr->data.w = w;
	spr->data.h = h;
	spr->data.img_fmt = fmt;
	spr->data.img_siz = siz;

	// Set properties
	spr->r = 255;
	spr->g = 255;
	spr->b = 255;
	spr->a = 255;
	spr->scale_x = 1;
	spr->scale_y = 1;
}

void sprite_destroy(sprite_t *spr)
{
	// free(spr);
}

void sprite_draw(sprite_t *spr)
{
	int t;
	int tiles = spr->data.tiles;

	setup_mtx(&(spr->data.mtx), spr->x, spr->y, spr->scale_x);

	// Set up DL
	gDPSetCycleType(glistp++, G_CYC_1CYCLE);
	gDPSetRenderMode(glistp++, G_RM_XLU_SPRITE, G_RM_XLU_SPRITE2);
	if (spr->data.tlut_fmt >= 0)
	{
		tlut.type = G_OBJLT_TLUT;
		tlut.image = (u64 *)&(spr->data.tlut);
		tlut.phead = GS_PAL_HEAD(0);
		tlut.pnum = GS_PAL_NUM(sizeof(spr->data.tlut));
		tlut.sid = 0;
		tlut.flag = (u32)&(spr->data.tlut);
		tlut.mask = 0xFFFFFFFF;

		gDPSetTextureLUT(glistp++, G_TT_RGBA16);
	}
	gSPObjRenderMode(glistp++, G_OBJRM_XLU | G_OBJRM_BILERP);

	// ******************************************

	// Setup matrices
	for (t = 0; t < tiles; t++)
	{
		// Set uObjSprite properties
		obj.s.objX = (spr->data.w * t) << 2;
		obj.s.objY = (spr->data.h * t) << 2;
		obj.s.imageW = (spr->data.w) << 5;
		obj.s.imageH = (spr->data.h) << 5;
		obj.s.imageStride = GS_PIX2TMEM(spr->data.w, spr->data.img_siz);
		obj.s.imageAdrs = GS_PIX2TMEM(0, spr->data.img_siz);
		obj.s.imageFmt = spr->data.img_fmt;
		obj.s.imageSiz = spr->data.img_siz;

		gDPSetPrimColor(glistp++, 0, 0, spr->r, spr->g, spr->b, spr->a);

		// Load texture as tile
		tex.type = G_OBJLT_TXTRTILE;
		tex.image = tiles > 1 ? (u64 *)(((u8 (*)[spr->data.w * spr->data.h])spr->data.tex)[0])
							  : (u64 *)((u16 *)(spr->data.tex));
		tex.tmem = GS_PIX2TMEM(0, spr->data.img_siz);
		tex.twidth = GS_TT_TWIDTH(spr->data.w, spr->data.img_siz);
		tex.theight = GS_TT_THEIGHT(spr->data.h, spr->data.img_siz);
		tex.flag = 0;
		tex.mask = 0xFFFFFFFF;
		gSPObjLoadTxtr(glistp++, &tex);

		// Load TLUT palette if it exists
		if (spr->data.tlut_fmt >= 0)
			gSPObjLoadTxtr(glistp++, &tlut);

		// Write matrix to DL
		osWritebackDCache(&(spr->data.mtx), sizeof(uObjMtx));
		gSPObjMatrix(glistp++, &(spr->data.mtx));

		osWritebackDCache(&obj, sizeof(uObjSprite));
		gSPObjSprite(glistp++, &obj);
		gDPPipeSync(glistp++);
	}
}