#include <ultra64.h>
#include "libultra-easy.h"

/* =================================================== *
 *                       MACROS                        *
 * =================================================== */

#define DMA_MSG_COUNT	50

/* =================================================== *
 *                     PROTOTYPES                      *
 * =================================================== */

static OSMesg		msg_pi[DMA_MSG_COUNT];
static OSMesgQueue	msg_queue_pi;
/*static*/ OSMesg		msg_dma;
static OSIoMesg		msg_io_dma;
/*static*/ OSMesgQueue	msg_queue_dma;

static bool			rom_reader_initialized = FALSE;

/*static*/ OSPiHandle* rom_handle;

/* =================================================== *
 *           GLOBAL FILEREADER/DMA FUNCTIONS           *
 * =================================================== */

void init_reader()
{
	if (!rom_reader_initialized)
	{
		// Init PI Messager for access to ROM
		rom_handle = osCartRomInit();
		osCreatePiManager((OSPri) OS_PRIORITY_PIMGR, &msg_queue_pi, msg_pi, DMA_MSG_COUNT);

		// Create msg queue for DMA
		osCreateMesgQueue(&msg_queue_dma, &msg_dma, 1);

		rom_reader_initialized = TRUE;
	}
}

// #define READ_IN_CHUNKS

void load_from_rom(void *ram_addr, char *rom_addr, int size)
{
	#ifdef READ_IN_CHUNKS
		void* ram_addr_temp = ram_addr;
		u32 rom_addr_temp = (u32)rom_addr;
		int read_size;
		int size_remaining = size;

		osWritebackDCacheAll();
		osInvalDCache(ram_addr, size);

		while (size_remaining > 0)
		{
			read_size = size_remaining > 16384 ? 16384 : size_remaining;

			msg_io_dma = (OSIoMesg)
			{
				.hdr = 
				{
					.pri = OS_MESG_PRI_NORMAL,
					.retQueue = &msg_queue_dma,
				},
				.dramAddr = ram_addr_temp,
				.devAddr = rom_addr_temp,
				.size = read_size,
			};

			osEPiStartDma(rom_handle, &msg_io_dma, OS_READ);
			osRecvMesg(&msg_queue_dma, &msg_dma, OS_MESG_BLOCK);
			osInvalDCache(ram_addr_temp, read_size);

			size_remaining -= read_size;
			rom_addr_temp += read_size;
			ram_addr_temp = (void*)((u8*)ram_addr_temp + read_size);
		}
	#else
		// osWritebackDCache((void *)ram_addr, (s32)size);
		// osInvalDCache((void *)ram_addr, (s32)size);
		osWritebackDCacheAll();

		msg_io_dma = (OSIoMesg)
		{
			.hdr = 
			{
				.pri = OS_MESG_PRI_NORMAL,
				.retQueue = &msg_queue_dma,
			},
			.dramAddr = (void *)ram_addr,
			.devAddr = (u32)rom_addr,
			.size = (u32)size,
		};

		osEPiStartDma(rom_handle, &msg_io_dma, OS_READ);
		(void) osRecvMesg(&msg_queue_dma, &msg_dma, OS_MESG_BLOCK);

		// osInvalDCache((void *)ram_addr, (s32)size);
	#endif
}

u8 get_rom_region()
{
	u8 rom_header[16];
	u8 *rom_header_ptr = rom_header;
	load_from_rom(rom_header_ptr, (char *)0x20, 16);
	return rom_header_ptr[0x0E];
}

void load_segment(char *offset, char *start, char *end)
{
	// Initialize Pi Manager/DMA queue if not done yet
	if (!rom_reader_initialized) { init_reader(); }

	// Determine parameters of where segment is stored and size
	msg_io_dma.hdr.pri      = OS_MESG_PRI_NORMAL;
	msg_io_dma.hdr.retQueue = &msg_queue_dma;
	msg_io_dma.dramAddr     = offset;
	msg_io_dma.devAddr      = (u32)start;
	msg_io_dma.size         = (u32)(end - start);

	// Start DMA reader and wait for message
	osEPiStartDma(rom_handle, &msg_io_dma, OS_READ);
	(void) osRecvMesg(&msg_queue_dma, NULL, OS_MESG_BLOCK);

	/* EXAMPLE SEGMENTS:

	// Static:
	staticSegment = _zbufSegmentBssEnd;
	msg_io_dma.hdr.pri      = OS_MESG_PRI_NORMAL;
	msg_io_dma.hdr.retQueue = &msg_queue_dma;
	msg_io_dma.dramAddr     = staticSegment;
	msg_io_dma.devAddr      = (u32)SEGMENT_START(static);
	msg_io_dma.size         = (u32)SEGMENT_END(static) - (u32)SEGMENT_START(static);
	osEPiStartDma(rom_handle, &msg_io_dma, OS_READ);

	// Texture:
	textureSegment = msg_io_dma.dramAddr + msg_io_dma.size;
	msg_io_dma.hdr.pri      = OS_MESG_PRI_NORMAL;
	msg_io_dma.hdr.retQueue = &msg_queue_dma;
	msg_io_dma.dramAddr     = textureSegment;
	msg_io_dma.devAddr      = (u32)SEGMENT_START(texture);
	msg_io_dma.size         = (u32)SEGMENT_END(texture) - (u32)SEGMENT_START(texture);
	osEPiStartDma(rom_handle, &msg_io_dma, OS_READ);
	*/
}

void load_all_segments()
{
	// RAM addresses generated by "makerom"

	// extern char _codeSegmentEnd[];

	// -----------------------------------------------------

	// ROM addresses generated by "makerom"
	// *************
	// For each numbered segment, there MUST be an address
	// specifying its beginning within the ROM and another
	// determining its end, and they must share the SAME
	// name as the segment itself in 'spec'!

	// SEGMENT_DECLARE(static);
	// SEGMENT_DECLARE(texture);

	// u32 location = (u32)_codeSegmentEnd;

	// -----------------------------------------------------

	// 'texture'
	/*read_segment
	(
		location,
		SEGMENT_START(texture),
		SEGMENT_END(texture)
	);
	location += ((u32)(SEGMENT_SIZE(texture)));*/
}