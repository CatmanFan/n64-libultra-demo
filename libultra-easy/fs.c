#include <ultra64.h>
#include "libultra-easy.h"

/* =================================================== *
 *                       MACROS                        *
 * =================================================== */

#define DMA_MSG_COUNT	200

/* =================================================== *
 *                     PROTOTYPES                      *
 * =================================================== */

static OSMesg		msg_pi[DMA_MSG_COUNT];
static OSMesgQueue	msg_queue_pi;
static OSMesg		msg_dma;
static OSIoMesg		msg_io_dma;
static OSMesgQueue	msg_queue_dma;

static bool			rom_reader_initialized = FALSE;

/*static*/ OSPiHandle* rom_handle;

/* =================================================== *
 *           GLOBAL FILEREADER/DMA FUNCTIONS           *
 * =================================================== */

void init_reader()
{
	if (!rom_reader_initialized)
	{
		// Init PI Messager for access to ROM
		rom_handle = osCartRomInit();
		osCreatePiManager((OSPri) OS_PRIORITY_PIMGR, &msg_queue_pi, msg_pi, DMA_MSG_COUNT);

		// Create msg queue for DMA
		osCreateMesgQueue(&msg_queue_dma, &msg_dma, 1);

		rom_reader_initialized = TRUE;
	}
}

void load_from_rom(void *ram_addr, void *rom_addr, u32 size)
{
	u32 src = (u32)rom_addr;
    osWritebackDCache(ram_addr, size);
    osInvalDCache(ram_addr, size);

    msg_io_dma.hdr.pri      = OS_MESG_PRI_NORMAL;
    msg_io_dma.hdr.retQueue = &msg_queue_dma;

    msg_io_dma.dramAddr     = ram_addr;
    msg_io_dma.devAddr      = src;
    msg_io_dma.size         = size;

    osEPiStartDma(rom_handle, &msg_io_dma, OS_READ);
    osRecvMesg(&msg_queue_dma, NULL, OS_MESG_BLOCK);
    osInvalDCache(ram_addr, size);
}

u8 get_rom_region()
{
	u8 rom_header[16];
	u8 *rom_header_ptr = rom_header;
	load_from_rom(rom_header_ptr, (u8 *)0x20, 16);
	return rom_header_ptr[0x0E];
}

void load_segment(char *offset, char *start, char *end)
{
	// Initialize Pi Manager/DMA queue if not done yet
	if (!rom_reader_initialized) { init_reader(); }

	// Determine parameters of where segment is stored and size
	msg_io_dma.hdr.pri      = OS_MESG_PRI_NORMAL;
	msg_io_dma.hdr.retQueue = &msg_queue_dma;
	msg_io_dma.dramAddr     = offset;
	msg_io_dma.devAddr      = (u32)start;
	msg_io_dma.size         = (u32)end-(u32)start;

	// Start DMA reader and wait for message
	osEPiStartDma(rom_handle, &msg_io_dma, OS_READ);
	(void) osRecvMesg(&msg_queue_dma, NULL, OS_MESG_BLOCK);

	/* EXAMPLE SEGMENTS:

	// Static:
	staticSegment = _zbufSegmentBssEnd;
	msg_io_dma.hdr.pri      = OS_MESG_PRI_NORMAL;
	msg_io_dma.hdr.retQueue = &msg_queue_dma;
	msg_io_dma.dramAddr     = staticSegment;
	msg_io_dma.devAddr      = (u32)SEGMENT_START(static);
	msg_io_dma.size         = (u32)SEGMENT_END(static) - (u32)SEGMENT_START(static);
	osEPiStartDma(rom_handle, &msg_io_dma, OS_READ);

	// Texture:
	textureSegment = msg_io_dma.dramAddr + msg_io_dma.size;
	msg_io_dma.hdr.pri      = OS_MESG_PRI_NORMAL;
	msg_io_dma.hdr.retQueue = &msg_queue_dma;
	msg_io_dma.dramAddr     = textureSegment;
	msg_io_dma.devAddr      = (u32)SEGMENT_START(texture);
	msg_io_dma.size         = (u32)SEGMENT_END(texture) - (u32)SEGMENT_START(texture);
	osEPiStartDma(rom_handle, &msg_io_dma, OS_READ);
	*/
}

void load_all_segments()
{
	// RAM addresses generated by "makerom"

	// extern char _codeSegmentEnd[];

	// -----------------------------------------------------

	// ROM addresses generated by "makerom"
	// *************
	// For each numbered segment, there MUST be an address
	// specifying its beginning within the ROM and another
	// determining its end, and they must share the SAME
	// name as the segment itself in 'spec'!

	// SEGMENT_DECLARE(static);
	// SEGMENT_DECLARE(texture);

	// u32 location = (u32)_codeSegmentEnd;

	// -----------------------------------------------------

	// 'texture'
	/*read_segment
	(
		location,
		SEGMENT_START(texture),
		SEGMENT_END(texture)
	);
	location += ((u32)(SEGMENT_SIZE(texture)));*/
}