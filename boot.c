#include <os.h>
#include <ultra64.h>
#include <PR/sched.h>

#include "debug.h"
#include "config.h"
#include "static.h"

/* ============= PROTOTYPES ============= */

static OSPiHandle* rom_handle;

static void idle(void *);
static void main(void *);

// Stacks
u64 boot_stack[STACK_SIZE_BOOT];
static u64 idle_stack[STACK_SIZE_IDLE];
static u64 main_stack[STACK_SIZE_MAIN];
static u64 scheduler_stack[OS_SC_STACKSIZE];

static OSThread idle_thread;
static OSThread main_thread;

/* ============== SEGMENTS ============== */

// RAM addresses generated by "makerom"
extern char _codeSegmentTextStart[];
extern char _codeSegmentTextEnd[];
extern char _codeSegmentEnd[];
// extern char _zbufferSegmentBssStart[];
// extern char _zbufferSegmentBssEnd[];

// ROM addresses generated by "makerom"
//
// For each numbered segment, there MUST be an address
// specifying its beginning within the ROM and another
// determining its end, and they must share the SAME
// name as the segment itself in 'spec'!

// 'static'
// extern char _staticSegmentRomStart[];
// extern char _staticSegmentRomEnd[];
// extern char* staticSegment;

/* ============== MESSAGES ============== */

// Required for hardware
static OSMesg msg_pi[NUM_PI_MSGS];
static OSMesg msg_gfx[NUM_GFX_MSGS];
static OSMesg msg_si[NUM_SI_MSGS];
static OSMesg msg_dma;
static OSMesgQueue msgQ_pi, msgQ_gfx, msgQ_si, msgQ_dma;
static OSIoMesg msgIo_dma;

// Additional
OSMesg msg_prenmi;
OSMesgQueue msgQ_prenmi;

static void init_messages()
{
	// Pre-NMI (signal triggered 0.5 seconds before system reset)
	osCreateMesgQueue(&msgQ_prenmi, &msg_prenmi, 1);
	osSetEventMesg(OS_EVENT_PRENMI, &msgQ_prenmi, NULL);
}

/* ============== GRAPHICS ============== */

// F3DEX2 matrix stack
static u64 dram_stack[SP_DRAM_STACK_SIZE8] __attribute__((aligned(16)));
// Display list processing results buffer
static u64 fifo_buffer[FIFO_SIZE] __attribute__((aligned(16)));
// Audio buffer
static u64 yield_buffer[OS_YIELD_DATA_SIZE] __attribute__((aligned(16)));

static Gfx glist[GL_SIZE];
static Gfx *glistp;

static int cfb_current = 0;
static void *cfb[2] = { (void *)CFB1_ADDR, (void *)CFB2_ADDR };
static u16 zbuffer[SCREEN_W * SCREEN_H];

/* =============== DEBUG ================ */

// Debug buffer

#define RDB_SEND_BUF_SIZE   2000

u8  rdbSendBuf[RDB_SEND_BUF_SIZE];

/* ============= SCHEDULER ============== */

OSSched scheduler;
OSScClient scheduler_client; // Used for frame synchronisation
OSScTask scheduler_task;     // Used for scheduler graphics tasks
OSScMsg scheduler_send_msg;  // Hold message for rendering being done
OSScMsg *scheduler_msg; 	 // Wait message for rendering being done

void init_scheduler()
{
	// Initialize video mode
	u8 video;
	u8 highres;
	
	#if SCREEN_W == 320 && SCREEN_H == 240
		highres = 0;
	#elif SCREEN_W == 640 && SCREEN_H == 480
		highres = 1;
	#else
		#error "Invalid resolution"
	#endif

	switch (osTvType) {
		case 0:
			video = highres == 1 ? OS_VI_PAL_HAN1 : OS_VI_PAL_LAN1;
			break;
		default:
		case 1:
			video = highres == 1 ? OS_VI_NTSC_HAN1 : OS_VI_NTSC_LAN1;
			break;
		case 2:
			video = highres == 1 ? OS_VI_MPAL_HAN1 : OS_VI_MPAL_LAN1;
			break;
	}

	// Create scheduler values using pointer to variable and stack
    osCreateScheduler(&scheduler, &scheduler_stack[OS_SC_STACKSIZE / sizeof(u64)], PR_SCHEDULER, video, 1);
	
	// Init messages
	osCreateMesgQueue(&msgQ_gfx, msg_gfx, NUM_GFX_MSGS);
	osScAddClient(&scheduler, &scheduler_client, &msgQ_gfx);
	
	// Specify register done message to OSScMsg
	scheduler_send_msg.type = OS_SC_DONE_MSG;
	
	// Set up graphics task for scheduler
	scheduler_task.list.t.type             = M_GFXTASK;
    scheduler_task.list.t.flags            = 0;
	// Set boot microcode to rspboot
	scheduler_task.list.t.ucode_boot       = (u64*)rspbootTextStart;
	scheduler_task.list.t.ucode_boot_size  = (u32)rspbootTextEnd - (u32)rspbootTextStart;
    scheduler_task.list.t.ucode            = (u64 *)gspF3DEX2_fifoTextStart;
	// Set microcode to FIFO F3DEX2
    scheduler_task.list.t.ucode_data       = (u64 *)gspF3DEX2_fifoDataStart;
    scheduler_task.list.t.ucode_size       = SP_UCODE_SIZE;
    scheduler_task.list.t.ucode_data_size  = SP_UCODE_DATA_SIZE;
	// DRAM stack
    scheduler_task.list.t.dram_stack       = (u64*)dram_stack;
    scheduler_task.list.t.dram_stack_size  = SP_DRAM_STACK_SIZE8;
	// Output buffer
	scheduler_task.list.t.output_buff      = fifo_buffer;
	scheduler_task.list.t.output_buff_size = &fifo_buffer[FIFO_SIZE / sizeof(u64)];
	// Yield buffer
	scheduler_task.list.t.yield_data_ptr   = yield_buffer;
	scheduler_task.list.t.yield_data_size  = OS_YIELD_DATA_SIZE;
	// Flags
	scheduler_task.flags = OS_SC_NEEDS_RSP | OS_SC_NEEDS_RDP | OS_SC_LAST_TASK | OS_SC_SWAPBUFFER;
	// Message queue for when task is finished rendering
	scheduler_task.msg  = (OSMesg)&scheduler_send_msg;
	scheduler_task.msgQ = &msgQ_gfx;
}

/* =========== MAIN FUNCTIONS =========== */

// Main N64 entry point.
void boot(void* arg)
{
	osInitialize();
	osCreateThread(&idle_thread, ID_IDLE, idle, arg, &idle_stack[STACK_SIZE_IDLE / sizeof(u64)], PR_IDLE);
	osStartThread(&idle_thread);
}

static void idle(void *arg)
{
	// Init PI Messager for access to ROM
	osCreatePiManager((OSPri) OS_PRIORITY_PIMGR, &msgQ_pi, msg_pi, NUM_PI_MSGS);
	rom_handle = osCartRomInit();
	
    osInitRdb(rdbSendBuf, RDB_SEND_BUF_SIZE);
	
	// Initialize main thread
	osCreateThread(&main_thread, ID_MAIN, main, arg, &main_stack[STACK_SIZE_MAIN / sizeof(u64)], PR_MAIN);
	osStartThread(&main_thread);

	// Relinquish CPU
	osSetThreadPri(NULL, 0);

	// Enter a permanent loop, so as to remain the only thread running if all others are absent.
	while (1) ;
}

static void init_dma()
{
	/* =========================== SEGMENTS =========================== */

	// Static
	/* staticSegment = _zbufSegmentBssEnd;
	msgIO_dma.hdr.pri      = OS_MESG_PRI_NORMAL;
	msgIO_dma.hdr.retQueue = &msgQ_dma;
	msgIO_dma.dramAddr     = staticSegment;
	msgIO_dma.devAddr      = (u32)_staticSegmentRomStart;
	msgIO_dma.size         = (u32)_staticSegmentRomEnd-(u32)_staticSegmentRomStart;
	osEPiStartDma(rom_handle, &msgIO_dma, OS_READ); */
	
	// Texture
	/* staticSegment = _zbufSegmentBssEnd;
	msgIO_dma.hdr.pri      = OS_MESG_PRI_NORMAL;
	msgIO_dma.hdr.retQueue = &msgQ_dma;
	msgIO_dma.dramAddr     = textureSegment;
	msgIO_dma.devAddr      = (u32)_textureSegmentRomStart;
	msgIO_dma.size         = (u32)_textureSegmentRomEnd-(u32)_textureSegmentRomStart;
	osEPiStartDma(rom_handle, &msgIO_dma, OS_READ); */
	
	/* =========================== RAW DATA =========================== */
}

Gfx clear_zfb[] = {
    gsDPSetDepthImage(OS_K0_TO_PHYSICAL(zbuffer)),
    gsDPSetColorImage(G_IM_FMT_RGBA, G_IM_SIZ_16b, SCREEN_W, OS_K0_TO_PHYSICAL(zbuffer)),
	gsDPSetCycleType(G_CYC_FILL),
    gsDPSetRenderMode(G_RM_NOOP, G_RM_NOOP2),
	gsDPSetFillColor(GPACK_ZDZ(G_MAXFBZ, 0) << 16 | GPACK_ZDZ(G_MAXFBZ, 0)),
    gsDPFillRectangle(0, 0, SCREEN_W - 1, SCREEN_H - 1),
    gsDPPipeSync(),
    gsSPEndDisplayList(),
};

Gfx clear_cfb[] = {
    gsDPSetColorImage(G_IM_FMT_RGBA, G_IM_SIZ_16b, SCREEN_W, 0),
	gsDPSetCycleType(G_CYC_FILL),
	gsDPSetFillColor(0),
    gsDPFillRectangle(0, 0, SCREEN_W - 1, SCREEN_H - 1),
    gsDPPipeSync(),
    gsSPEndDisplayList(),
};

static void main(void *arg)
{
	u8 r = 0;
	u8 g = 0;
	u8 b = 255;
	
	// Create scheduler
	init_scheduler();

	// Initialize message queues
	// init_messages();
	
	// Init raw files and segments
	init_dma();

	while (1)
	{
		// Init display list
		glistp = glist;

		// Set the segment register to segment #0
		// The addresses passed to the RCP must be in segment addresses
		// The CPU uses virtual addresses, this will convert accordingly
		gSPSegment(glistp++, 0, 0);

		// Execute RSP and RDP initialization
		gSPDisplayList(glistp++, OS_K0_TO_PHYSICAL(DL_initRDP));
		gSPDisplayList(glistp++, OS_K0_TO_PHYSICAL(DL_initRSP));
				
		osRecvMesg(&msgQ_gfx, (OSMesg *)&scheduler_msg, OS_MESG_BLOCK);
		switch (scheduler_msg->type)
		{
            case (OS_SC_RETRACE_MSG):
				b += 1;
				if (b >= 255) b = 0;

				// ---------------------------------
				
				clear_cfb[0] = (Gfx)gsDPSetColorImage(G_IM_FMT_RGBA, G_IM_SIZ_16b, SCREEN_W, OS_K0_TO_PHYSICAL(cfb[cfb_current]));
				clear_cfb[2] = (Gfx)gsDPSetFillColor(GPACK_RGBA5551(r, g, b, 1) << 16 | GPACK_RGBA5551(r, g, b, 1));
				
				// ---------------------------------
				
				gSPDisplayList(glistp++, clear_cfb);
				gSPDisplayList(glistp++, clear_zfb);
				
				// ---------------------------------
				
				// Finish the display list
				gDPFullSync(glistp++);
				gSPEndDisplayList(glistp++);
				
				// Normally there should be an assert function to check the display list limit here
				
				// Point scheduler task to display list and set framebuffer
				scheduler_task.list.t.data_ptr = (u64 *)glist;
				scheduler_task.list.t.data_size = (s32)(glistp - glist) * sizeof(Gfx);
				scheduler_task.framebuffer = cfb[cfb_current];
				
				// Writeback cache lines so that the RCP can read the up-to-date data
				osWritebackDCacheAll();
				
				// Send task
				osSendMesg(osScGetCmdQ(&scheduler), (OSMesg)&scheduler_task, OS_MESG_BLOCK);
				
				// Wait for rendering to finish
				do {
				osRecvMesg(&msgQ_gfx, (OSMesg *)&scheduler_msg, OS_MESG_BLOCK);
				} while (scheduler_msg->type != OS_SC_DONE_MSG);
				
				// Swap framebuffer
				cfb_current ^= 1;
				break;
		}
	}
}