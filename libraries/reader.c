#include <ultra64.h>
#include "config/global.h"

static OSMesg msg_pi[NUM_PI_MSGS];
static OSMesg msg_dma;
static OSMesgQueue msgQ_pi, msgQ_dma;
static OSIoMesg msgIo_dma;

static OSPiHandle* rom_handle;

void init_reader()
{
	// Init PI Messager for access to ROM
	osCreatePiManager((OSPri) OS_PRIORITY_PIMGR, &msgQ_pi, msg_pi, NUM_PI_MSGS);
	rom_handle = osCartRomInit();

	// Create msg queue for DMA
	osCreateMesgQueue(&msgQ_dma, &msg_dma, 1);
}

void load_segment(char *offset, char *start, char *end)
{
	// Static
	/* staticSegment = _zbufSegmentBssEnd;
	msgIo_dma.hdr.pri      = OS_MESG_PRI_NORMAL;
	msgIo_dma.hdr.retQueue = &msgQ_dma;
	msgIo_dma.dramAddr     = staticSegment;
	msgIo_dma.devAddr      = (u32)_staticSegmentRomStart;
	msgIo_dma.size         = ;
	osEPiStartDma(rom_handle, &msgIo_dma, OS_READ); */

	// Texture
	/* textureSegment = msgIo_dma.dramAddr + msgIo_dma.size;
	msgIo_dma.hdr.pri      = OS_MESG_PRI_NORMAL;
	msgIo_dma.hdr.retQueue = &msgQ_dma;
	msgIo_dma.dramAddr     = textureSegment;
	msgIo_dma.devAddr      = (u32)_textureSegmentRomStart;
	msgIo_dma.size         = (u32)_textureSegmentRomEnd-(u32)_textureSegmentRomStart;
	osEPiStartDma(rom_handle, &msgIo_dma, OS_READ); */

	// Determine parameters of where segment is stored and size
	msgIo_dma.hdr.pri      = OS_MESG_PRI_NORMAL;
	msgIo_dma.hdr.retQueue = &msgQ_dma;
	msgIo_dma.dramAddr     = offset;
	msgIo_dma.devAddr      = (u32)start;
	msgIo_dma.size         = (u32)end-(u32)start;

	// Start reading from ROM
	osEPiStartDma(rom_handle, &msgIo_dma, OS_READ);
}

void load_binary(void *rom_address, void *ram_buffer, int size)
{
	u32 src = (u32)rom_address;
	unsigned char *dest = ram_buffer;
	u32 data_read;

	msgIo_dma.hdr.pri      = OS_MESG_PRI_NORMAL;
	msgIo_dma.hdr.retQueue = &msgQ_dma;

	// Writeback and invalidate data cache
	osWritebackDCache(dest, size);
	osInvalDCache(dest, size);

	while (size)
	{
		// Cap to DMA block size if needed
		u32 max_size = 16384;
		data_read = size > max_size ? max_size : size;

		// Determine parameters of where binary is stored and size
		msgIo_dma.dramAddr = dest;
		msgIo_dma.devAddr  = src;
		msgIo_dma.size     = data_read;

		// Start reading from ROM and wait for message
		osEPiStartDma(rom_handle, &msgIo_dma, OS_READ);
		osRecvMesg(&msgQ_dma, NULL, OS_MESG_BLOCK);

		// Increment pointers for next ROM read
		src += data_read;
		dest += data_read;
		size -= data_read;
	}
}

void load_all_segments()
{
	// RAM addresses generated by "makerom"

	// extern char _codeSegmentEnd[];

	// -----------------------------------------------------

	// ROM addresses generated by "makerom"
	// *************
	// For each numbered segment, there MUST be an address
	// specifying its beginning within the ROM and another
	// determining its end, and they must share the SAME
	// name as the segment itself in 'spec'!

	// extern char _staticSegmentRomStart[];
	// extern char _staticSegmentRomEnd[];

	// extern char _textureSegmentRomStart[];
	// extern char _textureSegmentRomEnd[];

	// u32 size = 0;

	// -----------------------------------------------------

	// 'texture'
	/*read_segment
	(
		_codeSegmentEnd + size,
		_textureSegmentRomStart,
		_textureSegmentRomEnd
	);
	size += ((u32)_textureSegmentRomEnd-(u32)_textureSegmentRomStart);*/
}